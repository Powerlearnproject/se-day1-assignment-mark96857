[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=17029262&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering 

Explain what software engineering is and discuss its importance in the technology industry.
Software Engineering is the systematic use of the scientific and technical knowledge to design, develop, test, implement and maintain software. It is the disciplined application of methods, tools and processes for the purpose of designing, implementing, testing, and maintaining robust, effective, and maintainable software systems. This field is intermediate between programming and the development of extensive software systems in that it guarantees that created software is both high quality and suited to the user’s demands.
Ensures High-Quality Software
Software engineering practices always guarantee the quality of the end product in as far as the ability to meet the functional and non-functional requirements is concerned. This is important especially for business such as those in the healthcare, banking and transport sectors where software failure may lead to disastrous results.

Time and work efficiency and productivity of the company is increased.
Well-defined processes are that software engineers avoid wasting time and money in many instances because they complete many activities and projects in an efficient manner. Testing tools such as automated testing, continuous integration, â€¦ etc., allow short development cycles and also minimize mistakes.

Enables Scalability
Appropriate software engineering to the growth and development of the companies ensures that systems can be scaled up to cater for the increasing workload. For instance, web-based e-solutions should be able to accommodate millions of users at a given time.

Facilitates Collaboration
Software engineering is a very technical process, but it is a team sport in the sense that all the technical work needs to be documented clearly and modules need to be built such that they can readily be integrated with other completed modules, as happens with the use of source code control and release management tools such as Git. This allows developers work on big projects without much problems or some sort of quarrel that may arise from it.

Addresses Complexity
Current complex software systems including artificial intelligence applications, cloud services etc, are made up of components that are also complex. To overcome this complexity, software engineering has developed structures and gears which can be employed.

Economic Impact
There wide acceptance has placed software as a key input in world’s economies. Sound engineering of software supports various sectors which includes financial, health care, educational and entertaining sectors leading to development.

Using of software engineering
Artificial Intelligence: Creating models based on Machine Learning And Artificial Intelligence.
Web Development: Web development for the creation of highly usable, easily scalable websites and related applications.
Cybersecurity: Building framework to thwart cyber risks.
Embedded Systems: Software development to be applied in wearable technology gadgets such as smartwatches, IoT gadgets, and any other smart gadget that includes the use of technology in medical equipment.
Enterprise Solutions: Developing applications to support major endeavours like the enterprise resource planning systems or customer relationship management systems.


Identify and describe at least three key milestones in the evolution of software engineering.
1968: Birth of Software Engineering
Brought at the NATO conference to solve the “software crisis” based on a systematic engineering perspective.

1970: Waterfall Model
As long as the process followed a linear model as seen in other models such as Requirements, Design, and Testing phases.

2001: Agile Manifesto
Filed for evolution and flexibility, changing current software development practices altogether towards iterative implementation.


List and briefly explain the phases of the Software Development Life Cycle.
Planning
Determine the outline of what needs to be done in a project and how achievable it is in order to be feasible.

Requirements Analysis
Differentiate user requirements concerning the functionalities of the delivery system.

Design
Design overall and detailed system structures and layouts, interfaces and data base design layouts.

Implementation (Coding)
Design the software by coding and assembling new modules of code as well as by modifying existing modules of code.

Testing
In aspects of functionality, performance, and bugs check and reaffirm the efficacy of the software.

Deployment
Get the software out to people and set it to the production mode.

Maintenance
Report back to users, squash issues, and enhance the software as received from the users.


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Structure:

Waterfall is a sequential process where one phase complete before the next phase starts.
Agile instead structures the project in cycles,known as sprints.
Flexibility:

The Waterfall is very inflexible; modifications are hard to incorporate as soon as the development process is under way.
This is relatively flexible than the Waterfall model since changes to the requirements can be done even when the developers are in a middle of the development process.
Documentation:

Another area where Waterfall really bases itself is that of documentation with the work being planned and requirements gathered upfront.
Compared to linear methodologies, agile insists more on delivering work that is functional with less paperwork.
User Involvement:

In Waterfall model the user is involved in the process at the time of creating the requirements and again at the time of testing.
Agile guarantees that the project is always in touch with the users up to completion.
Delivery:

Waterfall on the other hand produces and delivers the product at the completion of the project.
During development, agile provides functional increments of the product in development.
Risk Management:

While with Waterfall model risks are recognized at the beginning of the phase, issues arise at the end of the phase are costly to rectify.
Risk is therefore managed with relative discretion by Agile, which conducts testing and iterations frequently.
Appropriate Scenarios
Waterfall:

Suitable for the most definite and concise specifications, for example, the creation of a hospital administration information system or firmware for a medical instrument.
Agile:

Best for projects that may change over time, including such mobile applications and artificial intelligence products where feedback is a priority.


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
Software Developer

Role: Develop, implement, debug and support software programs for use in applications.
Responsibilities:
Develop functionalities of the software according needs and specifications.
Do not write code that is complicated, not maintainable and not efficient.
You have to do the unit test while coding to improve code quality.
Integrate with other developers and teams for changes to be made for the system.
Based on feedback received, refine the bugs and make necessary improvement of the applications performance.
The role of a Quality Assurance (QA) Engineer

Role: Make sure the software have all the right qualities before installing it or in other words test it to confirm it performs the desired tasks optimally.
Responsibilities:
Construct test plans, test cases and test scripts.
Verification and validation should be done in order to discover the flaws.
Submit complaints/concerns and monitor them to completion.
Specifically, make certain that functional, performance and security requirements are all met by the software.
Cooperate with developers, in order to refine the quality of specific products.
Project Manager

Role: Supervise with the project planning, implementation and finally the project delivery of the software.
Responsibilities:
Identify and declare project objectives, objectives and the targets you want the project to achieve.
Organise and schedule projects and their elements with all necessary resources.
Report on the activity progress and report and control the risks and issues incurred.
Develop a communication link between the development team and the stakeholders.
Make sure the project goal is met on time, the cost of doing the project is well managed and the project meets the right standards.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
Code Assistance: To add, IDEs present features including syntax highlighting, autocompletion, as well as execution-time error checking, to enhance the correctness of code by the developers.
Debugging Tools: Integrated debuggers help developers follow code line by line in order to detect problematic issues and analyze variables.
Code Navigation: Integrated Development Environment makes it easy to move from file to class or from class to function if you are dealing with large projects.
Integration with Build and Test Systems: Most IDE helps to integrate with the build system and the testing tools eliminating several work steps manually.
Examples:
Visual Studio: A widely used platform for C#, C++, C, and.NET writing.
IntelliJ IDEA: Java development tool set and powerful IDE which also supports Kotlin, Groovy, other languages and platforms.
PyCharm: A package enhanced with code analysis and debugging features specially for Python and providing also the possibility of testing.
One of the reasons for the significance of VCS is Accessibility and Sharing.
VCS are systems to identify and handle the changes that over time occur to the code. Source control systems let the various developers keep track of the progress of one another, and the history of the code as the project grows without worrying about amendments becoming an issue during the developmental stage.

Key Benefits:
Collaboration: Several developers can be involved in the same project without interfering with other developers’ work.
Version History: As with all changes, VCS maintains a record of every code change, thus enabling developers amend or take back the changes in case they w.
Branching and Merging: When developers are working on new features or bug fixes, they can do them in branches which are not used, and later they integrate into the master branch.
Backup and Recovery: In VCS, it is somehow convenient to get back the code whenever there is an issue since earlier versions of your code will be intact.
Examples:
Git: The most popular VCS, especially when integrated with sites such as GitHub and GitLab allowing for distributed version control.
Subversion (SVN): A centralized system for version management which is still used at present in some multisite environments.
Mercurial: Is a decentralized version control system, which is similar to Git but has a more straightforward commands terminology.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Managing Complexity
Challenge: Since size and complexity increases as the project matures it becomes rather challenging to manage, enhance and debug large software systems.
Strategy:

Modularization: Isolate the system into modules or components where at least one component is easy to understand and easier to maintain.
Clear Documentation: Documentation should be well done to avoid complex issue when it comes to the navigation and understanding of the code.
Use Design Patterns: Utilize the design patterns as the approaches to structure solutions.
Dealing with Tight Deadlines
Challenge: Manufactured software products tend to have a time dimension whereby the software engineers working on it are under pressure to develop that code as much and as soon as possible which may lead to a compromise on the best quality code.
Strategy:

Agile Methodology: Adopt the Agile concepts to provide new smaller features in forms of incremental dyna shares so as to allow for frequent and faster change.
Time Management: Properly categorize work according to the urgency it deserves as well as according to the deadlines it is expected to meet. Ensure that you set small and realistic sub targets which help prevent situations in which an individual gets bored easily.
Automation: Minimise on hours spent in repetitive testing and deployment by automating on the processes.
Code Quality and Debugging
Challenge: Aiming at produce entirely error-free code and that can be easily maintained is not easy, while debugging can turn into epic and long procedures, having as result a large number of bugs that are hard to find or these bugs are challenging to solve.
Strategy:

Code Reviews: Some best practices are to do peer code reviews often in order to prevent simple mistakes from going unnoticed and getting to the deployment environment only to be observed there.
Automated Testing: To handle these issues, unit tests, integration tests, and CI pipelines should be integrated to detect them at an early stage.
Use Debugging Tools: Use main debugging tools, notifications and logs to pinpoint the error quickly.
Understanding and controlling the changing requirements
Challenge: Expectations from the stakeholders may change in the course of development process and force a change in the design and functioning of the software.
Strategy:

Agile/Scrum Methodology: In favor of fast response to changing requirements opt for iterative development and hard and fast feedback.
Clear Communication: Develop a proper and smooth reporting procedure to explain the changes to the actual and potential affected customers.
Documentation of Changes: Skin biomarkers genetics 2003pidemia skin biomarkers genetics 2003pidemia skin biomarkers genetics 2003pidemia Review changes made in the Course of development and their results to prevent confusion later during the project.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit Testing
Definition:
Unit testing involves testing individual units or components of the software (e.g., functions or methods) to ensure they work as expected in isolation.

Importance:

Early Detection of Bugs: Helps identify issues at the code level before they propagate to later stages.
Ensures Functionality: Verifies that individual components perform their intended tasks correctly.
Facilitates Refactoring: When unit tests are in place, developers can make changes with confidence, knowing the tests will catch regressions.
Example: Testing a function that calculates the total price of items in a shopping cart.

Integration Testing
Definition:
Integration testing focuses on verifying that different modules or components of the software interact correctly. It checks how well the individual parts work together as a whole.

Importance:

Validates Interfaces: Ensures data flow between modules is correct and that integrated components function as expected.
Identifies Interaction Issues: Helps catch errors that occur when different parts of the system interact (e.g., incorrect API responses or database integration problems).
Ensures Correct Data Transfer: Verifies that data passed between components is handled appropriately.
Example: Testing the interaction between the user login module and the database to ensure credentials are validated correctly.

System Testing
Definition:
System testing evaluates the entire software application as a complete system. It checks whether all components work together as intended in an environment that simulates real-world conditions.

Importance:

End-to-End Functionality: Confirms that the entire system functions according to requirements.
Identifies System-Level Issues: Tests the system's performance, security, and usability under different scenarios.
Verifies Non-Functional Requirements: Ensures that non-functional aspects like performance, scalability, and security are met.
Example: Testing a complete e-commerce website, including its UI, database, payment gateway, and user authentication.

Acceptance Testing
Definition:
Acceptance testing determines whether the software meets the business requirements and is ready for release to the end users. It is often performed by the client or end-users.

Importance:

Validation Against Requirements: Ensures that the software delivers the desired functionality and meets customer needs.
User Confidence: Provides confidence that the software is ready for deployment and will meet users' expectations.
Stakeholder Approval: It is often the final phase of testing before the product is delivered to the client or made public.
Example: A client tests a newly developed customer relationship management (CRM) system to ensure it meets the specified business processes.




#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
“Prompt Engineering” refers to the ability to create and fine tune input prompts to best engage with AI models, most commonly used language models such as GPT. Improving Response Quality
Well-crafted prompts assist the AI models capture the master’s intention more correctly hence improving on the type and quality of results produced. Use of the right prompt enables the AI to produce an appropriate set of answers that will be desirable in terms of compliance to a certain standard or preference.

Reducing Ambiguity
Its advantage is that the prompt engineering brings less room for further ambiguity for the AI in how the input is understood/misunderstood. Because the user obliges the AI with specifics like tone, format or context necessary responses are guaranteed to meet the user’s expectations.

Efficiency in Task Completion
Unambiguous instructions are provided to elicit rapid and more relevant reactions and prevent going back and forth as the user tries to get the system’s attention to facilitate the provision of the information requested.

Enhancing User Experience
Specifically, when users form proper prompts, they can converse with AI, and get responses that seem to be conversational or personalized, which contributes to the whole satisfaction level.

Distinguished Version for Specific Applications
In particular, users can effectively adapt the AI to her certain tasks, e.g., providing technical information and explanations, writing articles, or analysing data, and it will function well within certain domains or at least certain industries.



Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Vague Prompt:
“Sir, can you explain what climate change is”?

Improved Prompt:
Improved Prompt:
“Suggest the leading reasons as to why climate change occurs and how this issue affects the world weather system supported by science findings as well as shift within the current decades.”

Explanation of Why the Improved Prompt is More Effective:
Clear:
The improved prompt gives the user a clearer idea of what they want to know – the causes of climate change and the effect it has on the climate.

Specific:
It limits the scope of the response by identifying where information should be searched – scientific evidence and recent trends.

Concise:
The improved prompt is also concise, as it should be, but also offers the AI sufficient specificity to tailor a pertinent and comprehensive answer without excessive information.


